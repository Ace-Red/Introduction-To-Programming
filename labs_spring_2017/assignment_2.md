---
layout: default
---
[Повернутись](../index.md)
# [](#header-1)Assignment #1 – Data structures

Варіант завдання – остача від ділення номеру залікової книжки на 3. Варіантами можна _обмінюватись_, 
але не можна просто змінювати за власним бажанням. Також уважно ознайомтесь з загальними правилами здачі лабораторних та принципами оцінювання. 

Для підготовки до здачі роботи рекомендуємо користуватись книгою [Кормена](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B:_%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B8_%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7) або [Скієни](http://www.twirpx.com/file/736147/) (їх можна знайти в мережі в електронному вигляді), а також будь-якими іншими джерелами – про базові структури даних існує безліч текстової інформації та відео.

## Питання та необхідні знання
Друга робота знайомить вас із імплементацією структур даних, які надалі використовуватимуться у більшості програм, які ви будете писати. Отже для повноцінної здачі вам треба: 
* Знати, що таке О-велике і для чого воно використовується.
* Розуміти, чому алгоритми та структури, запропоновані в цій роботі, мають ту чи іншу асимптотичну слкадність *(вивчити напам'ять не значить зрозуміти)*.
* Мати уявлення, в яких випадках краще використовувати одні структури, а в яких – інші.
* Розбиратися в структурах stack, queue, priority queue, heap, linked list, doubly linked list, hash table.
* Пошук шляху у графі, алгоритм Дейкстри та `А*`
* Мати поняття, що таке евристика

## [](#header-4)Варіант #0. Обчислення арифметичного виразу
Обчислити результат математичного виразу, що подається на вхід програми через аргументи командного рядка. Наприклад, якщо ваша програма компілюється у файл calc.exe, вона має запускатися через командний рядок так:
```
> calc.exe 1 + 2 * 4+1 [Enter]
Result: 10
```
*Перевіряти введені дані на правильність в цьому варіанті не обов'язково!*

Для вирішення задачі треба реалізувати алгоритм [сортувальної станції](https://en.wikipedia.org/wiki/Shunting-yard_algorithm), що дозволяє обчислювати значення введеного арифметичного виразу. Стандартний спосіб зробити сортувальну станцію – використувати два стеки. Структуру стек необхідно написати власноруч.
*Додаткове завдання (+1 бал):* Додати обробку дужок та степенів *(також без перевірки на правильність вводу)*.

### Вхідні та вихідні дані
На вхід програми через аргументи командного рядка подається арифметичний вираз (`2 + 4*3`), що складається з чисел та символів +,-,\*,/. Вивід – результат обчислення (`14`).

### Посилання
* [Алгоритм сортувальної станції](https://en.wikipedia.org/wiki/Shunting-yard_algorithm)
* [Інфіксний, постфіксний та префіксний записи](http://www.cs.man.ac.uk/~pjj/cs2121/fix.html)
* Структура даних стек - операції, реалізація ([лінк](http://informatics.mccme.ru/mod/book/view.php?id=580), [ще лінк](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)))

Стек – одна із найбільш часто використовуваних структур. Використовується в [компіляторах](http://softwareengineering.stackexchange.com/questions/165543/how-to-write-a-very-basic-compiler) для розбору вихідних кодів. В [мікропроцесорах](http://stackoverflow.com/questions/1114047/what-is-the-role-of-stack-in-a-microprocessor) та [комп'ютерах](https://en.wikipedia.org/wiki/Call_stack) стек використовується для передачі параметрів в функції та рекурсивних викликів. 

## [](#header-4)Варіант #1. Пошук найкоротшого шляху
Знайти в заданому лабіринті найкоротший шлях між двома точками за допомогою [алгоритму А\*](https://en.wikipedia.org/wiki/A*_search_algorithm). Щоб написати цей алгоритм, треба скористатися структурою даних queue, яку треба написати власноруч. Вам знадобиться кілька черг, по одній для кожного пріоритету. Проте для ефективної імплементації цієї задачі зазвичай використовують складніші структури.

*Додаткове завдання (+1 бал):* Реалізувати пріоритетну чергу більш ефективною структурою (наприклад, binary heap).

### Вхідні та вихідні дані
Вхідний лабіринт задається у файлі форматованою двовимірною матрицею. В коді задається точка початку пошуку шляху та кінцева точка. Приклад вхідних даних:
```
X X X X X X X X   
X       X X   X   
X   X   X X   X   
X   X         X   
X   X   X   X X     
X   X   X   X X   
X   X       X X   
X X X X X X X X 
```
Вивід – візуалзіація роботи алгоритму (у файл або на екран)
```
X X X X X X X X   
X 5 6 7 X X e X   
X 4 X 8 X X d X   
X 3 X 9 a b c X   
X 2 X   X   X X    
X 1 X   X   X X  
X   X       X X  
X X X X X X X X  
```
### Посилання
* [Алгоритм А\*](https://en.wikipedia.org/wiki/A*_search_algorithm)
* [Бінарна купа](https://en.wikipedia.org/wiki/Binary_heap)
* [Пошук шляху](https://en.wikipedia.org/wiki/Pathfinding)

Пошук шляху дуже часто використовується для [трасування електричних плат](https://en.wikipedia.org/wiki/Routing_(electronic_design_automation)); для маршрутизації пакетів у [комп'ютерних мережах](https://en.wikipedia.org/wiki/Routing); для написання [AI в іграх](https://arongranberg.com/astar/). Черги та пріоритетні черги використовуються в ОС для контролю [доступу до ресурсів](https://github.com/torvalds/linux/blob/b3a3a9c441e2c8f6b6760de9331023a7906a4ac6/include/linux/prio_heap.h); для [імплементації](https://github.com/torvalds/linux/blob/master/include/linux/plist.h) м'ютексів та черги виконання процесів; в іграх та 3D-програмах для [рендерингу місцевості (terrain)](https://en.wikipedia.org/wiki/ROAM); в алгоритмах стискання зображень/музики/файлів – [кодування Хаффмана](https://en.wikibooks.org/wiki/JPEG_-_Idea_and_Practice/The_Huffman_coding).

